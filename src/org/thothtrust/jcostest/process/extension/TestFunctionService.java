package org.thothtrust.jcostest.process.extension;import java.io.DataInputStream;import java.io.File;import java.io.FileInputStream;import java.util.*;import interfaces.TestFunctionInterface;public class TestFunctionService extends ClassLoader {	private static TestFunctionService wsInstance;	static String pluginsDir = "ext";	static String pluginPackageQualifiedName = "interfaces.TestFunctionInterface";	File directory;	static ArrayList<TestFunctionInterface> plugins = null;	public static synchronized TestFunctionService getInstance() {		if (wsInstance == null) {			wsInstance = new TestFunctionService();		}		return wsInstance;	}	protected TestFunctionService() {		plugins = new ArrayList<>();	}	public void loadPlugins() {		loadPlugins(pluginsDir, "");	}	protected void loadPlugins(String directory, String parent) {		File dir = new File(System.getProperty("user.dir") + File.separator + directory);		if (dir.exists() && dir.isDirectory()) {			String[] files = dir.list();			for (int i = 0; i < files.length; i++) {				try {					// Allows recursive targetting of nested directories					String newTargetFile = System.getProperty("user.dir") + File.separator + directory + File.separator							+ files[i];					System.out.println("Targetting: " + newTargetFile);					File currentTarget = new File(newTargetFile);					if (currentTarget.isDirectory()) {						String newDirectoryTarget = directory + File.separator + files[i];						loadPlugins(newDirectoryTarget, files[i]);					}					if (!files[i].endsWith(".class"))						continue;					String childFile = parent + "." + files[i].substring(0, files[i].indexOf("."));					Class c = loadClass(childFile);					Class[] intf = c.getInterfaces();					for (int j = 0; j < intf.length; j++) {						System.out.println("Interface - " + intf[j].getName());						if (intf[j].getName().equals(pluginPackageQualifiedName)) {							TestFunctionInterface pf = (TestFunctionInterface) c.newInstance();							plugins.add(pf);							System.out.println("Adding plugin ...");							continue;						} else {							System.out.println("Not PluginFunction type plugin ...");						}					}				} catch (Exception ex) {					System.err.println("File " + files[i] + " does not contain a valid PluginFunction class.");					ex.printStackTrace();				}			}		}	}	public Class loadClass(String name) throws ClassNotFoundException {		return loadClass(name, true);	}	public Class loadClass(String classname, boolean resolve) throws ClassNotFoundException {//		System.out.println("Classname: " + classname);		try {			Class c = findLoadedClass(classname);			if (c == null) {				try {					c = findSystemClass(classname);				} catch (Exception ex) {				}			}			if (c == null) {				String[] classpathElements = classname.split("\\.");				String filename = "";				String filepath = this.pluginsDir;				for (int i = 0; i < classpathElements.length; i++) {					if (i == classpathElements.length - 1) {						filename = classpathElements[i];					} else {						filepath += "/" + classpathElements[i];					}				}				String targetFile = filepath + "/" + filename + ".class";				System.out.println("Loading target class file: " + targetFile);				File f = new File(targetFile);				int length = (int) f.length();				if (length > 0) {					byte[] classbytes = new byte[length];					DataInputStream in = new DataInputStream(new FileInputStream(f));					in.readFully(classbytes);					in.close();					c = defineClass(classname, classbytes, 0, length);				} else {					System.out.println("File not found !!!");					return null;				}			}			if (resolve)				resolveClass(c);			return c;		} catch (Exception ex) {			throw new ClassNotFoundException(ex.toString());		}	}	public static TestFunctionInterface findLoadedPluginByClasspath(String classpath) {		System.out.println("Finding plugin by classpath: " + classpath);		Iterator iter = plugins.iterator();		while (iter.hasNext()) {			TestFunctionInterface pf = (TestFunctionInterface) iter.next();			System.out.println("Searching class: " + pf.getClass().getName());			if (pf.getClass().getName().trim().equals(classpath.trim())) {				System.out.println("Found plugin ...");				return pf;			}		}		return null;	}		public static TestFunctionInterface findLoadedPluginByPos(int pos) {		return plugins.get(pos);	}		public ArrayList<TestFunctionInterface> getPlugins() {		return plugins;	}}